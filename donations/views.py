from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
import uuid
from django.urls import reverse
from django.contrib import messages
from .paystack import checkout
from projects.models import Project
from .models import DonationHistory
from django.views.decorators.csrf import csrf_exempt
from django.http import HttpResponse
import hmac
import hashlib
import json
from django.contrib.auth.models import User
from decimal import Decimal, InvalidOperation
from django.conf import settings


def _donation_limits():
  min_amount = Decimal(str(getattr(settings, "DONATION_MIN_AMOUNT", 100)))
  max_amount = Decimal(str(getattr(settings, "DONATION_MAX_AMOUNT", 1000000)))
  return min_amount, max_amount

def donation_checkout(request, donation_id):
  project = Project.objects.get(id=donation_id)
  min_amount, max_amount = _donation_limits()
  context = {
    "project": project,
    "min_amount": min_amount,
    "max_amount": max_amount,
  }
  return render(request, "donations/donation_checkout_form.html", context)


def donation_success(request, project_id):

  project = Project.objects.get(id=project_id)
  
  # Get the most recent successful donation for this user and project
  donation = DonationHistory.objects.filter(
      user=request.user,
      project=project,
      donation_status=True
  ).order_by('-date').first()
  
  amount = donation.amount if donation else None
  donation_id = donation.donation_id if donation else None
  is_anonymous = donation.is_anonymous if donation else False
  donor_name = None if is_anonymous else (request.user.get_full_name() or request.user.username)

  return render(request, 'donations/donation_success.html', {
      'project': project,
      'amount': amount,
      'donation_id': donation_id,
      'donor_name': donor_name,
      'is_anonymous': is_anonymous,
  })


def donation_failed(request, project_id):

  project = Project.objects.get(id=project_id)
    
  # Get the most recent failed donation for this user and project (optional)
  donation = DonationHistory.objects.filter(
      user=request.user,
      project=project,
      donation_status=False
  ).order_by('-date').first()
  
  amount = donation.amount if donation else None
  donation_id = donation.donation_id if donation else None
  
  return render(request, 'donations/donation_failed.html', {
      'project': project,
      'amount': amount,
      'donation_id': donation_id
  })


def create_paystack_checkout_session(request, project_id):
  project = Project.objects.get(id=project_id)
  min_amount, max_amount = _donation_limits()

  if request.method == "POST":
      amount_text = request.POST.get("amount")
      try:
          amount = Decimal(amount_text)
      except (InvalidOperation, TypeError):
          messages.error(request, "Enter a valid numeric amount.")
          return redirect('donations:donation', donation_id=project_id)

      is_anonymous = request.POST.get("is_anonymous", "false") == "true"

      if amount < min_amount or amount > max_amount:
          messages.error(
              request,
              f"Please enter an amount between KES {min_amount:,.0f} and KES {max_amount:,.0f}.",
          )
          return redirect('donations:donation', donation_id=project_id)
      
      purchase_id = f"purchase_{uuid.uuid4()}"
      # /donation-success/2/
      payment_success_url = reverse('donations:donation-success', kwargs={'project_id': project_id})
      # http://domain.com/donation-success/2/ 
      callback_url = f"{request.scheme}://{request.get_host()}{payment_success_url}"
      # Paystack expects amount in kobo (or cents) as integer
      amount_in_kobo = int(amount * 100)

      checkout_data = {
      "email": request.user.email,
      "amount": amount_in_kobo,  # in kobo 
      "currency": "KES",
      "channels": ["card", "bank_transfer", "bank", "ussd", "qr", "mobile_money"],
      "reference": purchase_id, # generated by developer
      "callback_url": callback_url,
      "metadata": {
          "product_id": project.id,
          "user_id": request.user.id,
          "purchase_id": purchase_id,
          "is_anonymous": is_anonymous,
      },
      "label": f"Checkout For {project.name}"
      }
      
      status, check_out_session_url_or_error_message = checkout(checkout_data)

      if status:
          return redirect(check_out_session_url_or_error_message)
      else:
          messages.error(request, check_out_session_url_or_error_message)
          return redirect('donations:donation', donation_id=project_id)
  # GET: render form to enter amount
  return render(request, 'donations/donation_checkout_form.html', {'project': project, 'min_amount': min_amount, 'max_amount': max_amount})

@csrf_exempt
def paystack_webhook(request):
    secret = settings.PAYSTACK_SECRET_KEY
    request_body = request.body
    
    hash = hmac.new(secret.encode('utf-8'), request_body, hashlib.sha512).hexdigest()
    
    if hash == request.META.get('HTTP_X_PAYSTACK_SIGNATURE'):
        webhook_post_data = json.loads(request_body)
       
        if webhook_post_data["event"] == "charge.success":
            metadata = webhook_post_data["data"]["metadata"]
            data = webhook_post_data["data"]
            product_id = metadata["product_id"]
            user_id = metadata["user_id"]
            purchase_id = metadata["purchase_id"]

            amount_paid_kobo = data.get("amount")
            amount_paid = Decimal(amount_paid_kobo) / 100

            user = User.objects.get(id=user_id)

            is_anonymous = metadata.get("is_anonymous", False)
            if isinstance(is_anonymous, str):
                is_anonymous = is_anonymous.lower() == "true"

            DonationHistory.objects.create(
                donation_id = purchase_id,
                user = user,
                donation_status = True,
                project = Project.objects.get(id=product_id),
                amount = amount_paid,
                is_anonymous = is_anonymous
            )

            #send email to user on successful payment
            # send_payment_success_email(user.email, product_id)

    return HttpResponse(status=200)

